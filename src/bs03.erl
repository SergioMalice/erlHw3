%%%-------------------------------------------------------------------
%%% @author sergeyb
%%% @copyright (C) 2019, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 25. Июнь 2019 20:11
%%%-------------------------------------------------------------------
-module(bs03).
-author("sergeyb").

%% API
-export([split/2]).
-define(TEST, 1).

% split/1 разбивает бинарник на слова, с явным указанием разделителя. Пример:
% 1> BinText = <<"Col1-:-Col2-:-Col3-:-Col4-:-Col5">>.
% <<"Col1-:-Col2-:-Col3-:-Col4-:-Col5">>
% 2> bs03:split(BinText, "-:-").
% [<<"Col1">>, <<"Col2">>, <<"Col3">>, <<"Col4">>, <<"Col5">>]
%
% Решение очень похожее на предыдущую задачу, за исключением того,
% что нам приходится проверять не появление пробела, а поочередно каждого
% символа из заданной строки разделителя.
%
% Очередной кусок памяти бинарника совпал с очередным (не последним [Symbol|T=[_|_]])
% символом из строки разделителя? Рекурсивно проверяем совпадение со следующим, записав в FakeWord этот символ
% на случай, если разделитель совпадет не до конца.
%
% Обнаружилось совпадение с последним символом [Symbol|[]]? Значит, разделитель полностью совпал.
% Добавляем в результат слово Word, которое было записано до обнаружения разделителя.
% Храним копию строки разделителя, чтобы можно было ее разбивать посимвольно для сравнения.
%
% Очередной символ бинарника не совпадает с разделителем? Тут два варианта.
% 1) несовпадение произошло, когда очередной символ разделителя не совпал, и сравнение не произошло до конца.
% В этом случае, FakeWord не пустой и там хранится кусок разделителя, который нужно добавить к слову.
% Добавляем к склейке Word с куском "ложного" разделителя, очередной символ, очищаем FakeWord
% 2) посимвольный поиск разделителя прошел успешно до самого конца.
% В этом случае, FakeWord пустой. Начинаем наполнение нового слова.
%
% Ну и в итоге, после обхода всего бинарника, возвращаем результат, который перевернут.


split(Bin, Sep) -> split(Bin, Sep, Sep, <<>>, <<>>, []).



split(<<Symbol/utf8, Rest/binary>>, Sep, [Symbol|[]], Word, _, Acc) -> % весь раздилитель совпал
  split(Rest, Sep, Sep, <<>>, <<>>, [Word|Acc]);

split(<<Symbol/utf8, Rest/binary>>, Sep, [Symbol|T=[_|_]], Word, FakeWord, Acc) -> % очередной символ разделителя совпал
  split(Rest, Sep, T, Word, <<FakeWord/binary, Symbol/utf8>>, Acc);

split(<<C/utf8, Rest/binary>>, Sep, _Symbol, Word, <<FakeWord/binary>>, _Acc) -> % ложный разделитель
  split(Rest, Sep, Sep, <<Word/binary, FakeWord/binary, C/utf8>>, <<>>, _Acc);

split(<<C/utf8, Rest/binary>>, _Sep, _Symbol, Word, <<>>, _Acc) -> % обычный набор слова
  split(Rest, _Sep, _Symbol, <<Word/binary, C/utf8>>, <<>>, _Acc);

split(<<>>, _, _, Word, _, Acc) -> reverse([Word|Acc]).



reverse(List) -> reverse(List, []).

reverse([], Res) -> Res;
reverse([H|T], Res) -> reverse(T, [H|Res]).

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
bs03_test() -> ?assert(split(<<"Col1-:-Col2-:-Col3-:-Col4-:-Col5">>, "-:-") =:= [<<"Col1">>, <<"Col2">>, <<"Col3">>, <<"Col4">>, <<"Col5">>]).

-endif.